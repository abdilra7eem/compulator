{"version":3,"sources":["Compulator.js","serviceWorker.js","index.js"],"names":["Button","props","myid","value","onClick","clickHandler","id","style","gridArea","Buttons","type","values","map","x","key","i","console","trace","Screen","Compulator","nums","Array","from","length","v","push","ops","split","useState","screen","setScreen","memory","setMemory","op","setOp","typing","setTyping","useEffect","window","addEventListener","onDown","removeEventListener","event","log","document","getElementById","click","toString","includes","opIndex","indexOf","KBNumPad","newScreen","replace","startsWith","result","res","parseFloat","calculate","isNaN","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.8095e375.chunk.js","sourcesContent":["import React, {useState, useEffect} from 'react';\nimport './reset.css';\nimport './compulator.css';\n\n  // The 'Button' component is a template for each individual button\nfunction Button(props) {\n  let myid = (props.value === '.') ? 'btndot': props.myid; // CSS grids did not accept \"btn.\"\n  return(\n    <button onClick={() => {props.clickHandler(props.value)}} id={myid} style={{gridArea: myid}}>{props.value}</button>\n  )\n}\n\n// The 'Buttons' component creates buttons based on the \"Button\" template an array of elements\nfunction Buttons(props){\n  if (props.type===\"nums\"){\n    return(\n        props.values.map(x => <Button clickHandler={props.clickHandler} value={x} key={x} myid={`btn${x}`} />)\n    )\n  } else if(props.type===\"ops\") {\n    return (\n      props.values.map((x,i) => <Button clickHandler={props.clickHandler} value={x} key={`op${i}`} myid={`op${i}`} />)\n    )\n  } else {\n    console.trace(\"ERROR! unknown button-set type\")\n  }\n}\n\n// the Screen component resembles the screen of the calculator\nfunction Screen(props){\n  return(\n    <div id='screen'>\n      {props.value || 0}\n    </div>\n  )\n}\n\n\n\n// Compulator is the main calculator component\nfunction Compulator() {\n\n  // Create arrays for the buttons. 'num' represents numbers, and 'ops' represents operations\n  // For performance, set the values of the arrays manually (e.g.: let nums = [0,1,2,3,4,5,6,7,8,9]) instead.\n  let nums = Array.from({length: 10}, (v, i) => i);\n  nums.push('.');\n  let ops = '=+-*/'.split('');\n  ops.push('AC');\n\n  // State variables needed for the calculator\n  const [screen, setScreen] = useState(0); // the screen content\n  const [memory, setMemory] = useState(0); // the memory contains the previous number\n  const [op, setOp] = useState(''); // the previous operator; it's used when the next operator button is pressed\n  const [typing, setTyping] = useState(false); // save the state of the last pressed button: true for numbers, false for operators\n\n  // Called by the number buttons\n  const numClick = (value) => {\n    console.log(`Number ${value} pressed`);\n    if (typing === true){\n      if (!(value==='.' && (screen.toString()).includes('.'))){//Avoid multiple decimal separators\n        let newScreen = `${screen}${value}`.replace(/^0+/, ''); // Remove leading zeros\n        newScreen = newScreen.startsWith('.') ? \"0\"+newScreen: newScreen; // Adds a leading zero if 'screen' starts with a decimal separator\n        setScreen(newScreen);\n      }\n    }else if (value !== '.'){\n      setScreen(value);\n    }\n    setTyping(true);\n  }\n\n  // 'calculate' evaluates the operator and does the calculation\n  // parseFloat is used because JS is weakly typed.\n  const calculate = ()=>{\n    let res = 0;\n    console.log(`function calculate called with ${memory} ${op} ${screen}`);\n    switch(op){\n      case ('+' || '='):\n        res = parseFloat(memory) + parseFloat(screen);\n        break;\n      case '-':\n        res = parseFloat(memory) - parseFloat(screen);\n        break;\n      case '*':\n        res = parseFloat(memory) * parseFloat(screen);\n        break;\n      case '/':\n        res = parseFloat(memory) / parseFloat(screen);\n        break;\n      default:\n        console.log('calculate: Unexpected error occured');\n    }\n    console.log(`${memory} ${op} ${screen} = ${res}`);\n    return(res);\n  }\n\n  // Called by operation buttons (+, -, *, /, =, AC)\n  const opClick = (value) => {\n\n    console.log('Previous operator: '+op+', Next operator: '+value);\n    let result = 0;\n    // 'op' is the previous operator, 'value' is the currently pressed button operator\n    if (value === 'AC'){\n      // When 'AC' is pressed, both 'memory' and 'screen' are reset.\n        setMemory(0);\n        setScreen(0);\n        console.log('cleared everything', memory, screen);\n    }else if(op === '' || op === '=' || op === 'AC'){\n      // If there is no previous operator, no calculation will be done\n      console.log ('op: \"\", =, AC');\n      result = (value==='=' ? 0 : screen ) // the memory will be reset when '=' is pressed\n    } else {\n      // The code to be run if there was a previous operator\n      console.log('should calculate now');\n      result = calculate();\n      console.log(`calculate says: ${result}`);\n      if (isNaN(result)){ // to avoid NaN values (Happens when multiplying infinity by zero)\n        result=0;\n      }\n    }\n\n    console.log('result is: '+result);\n    setOp(value.toString()); // set 'op' to the currently pressed operator button\n    setMemory(result);\n    setScreen(result);\n    setTyping(false);\n  }\n\n  // KeyboardEvents\n  const KBNumPad = (key)=>{\n    useEffect(() => {\n      window.addEventListener(\"keydown\", onDown)\n      return () => {\n          window.removeEventListener(\"keydown\", onDown)\n      }\n    }, [key]);\n  \n    const onDown = event => {\n      // Checks which key is pressed; if the key is relevant, a click event is issued to the relevant button\n      // Why 'click' events? Directly calling the numClick functions caused unpredictable behaviour in certain test cases.\n\n      console.log(event); // For debugging\n\n      if (event.key === '.'){\n        document.getElementById(`btn.`).click();\n      } else if (event.key === 'Escape') {\n        document.getElementById(`op5`).click();\n      } else if (event.key === 'Enter') {\n        document.getElementById(`op0`).click();\n      } else if ((nums.toString()).includes(event.key)) {\n        document.getElementById(`btn${event.key.toString()}`).click()\n      } else if((ops.toString()).includes(event.key)){\n        let opIndex = ops.indexOf(event.key);\n        document.getElementById(`op${opIndex}`).click();\n      } else {\n        console.log(`Irrelevant key ${event.key} pressed`);\n      }\n\n    }\n  }\n\n  KBNumPad();\n  \n  return (\n    <div id=\"Compulator\">\n      <Screen value={screen}/>\n      <Buttons clickHandler={numClick} values={nums} type='nums' />\n      <Buttons clickHandler={opClick} values={ops} type='ops' />\n    </div>\n  );\n}\n\nexport default Compulator;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Compulator from './Compulator';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<Compulator />, document.getElementById('calcContainer'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}